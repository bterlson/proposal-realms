{"version":3,"file":"realm-shim.min.js","sources":["../src/utilities.js","../src/realmFacade.js","../src/stdlib.js","../src/repair/accessors.js","../src/repair/functions.js","../src/unsafeRec.js","../src/optimizer.js","../src/scopeHandler.js","../src/sourceParser.js","../src/evaluators.js","../src/realm.js","../src/commons.js"],"sourcesContent":["// we'd like to abandon, but we can't, so just scream and break a lot of\r\n// stuff. However, since we aren't really aborting the process, be careful to\r\n// not throw an Error object which could be captured by child-Realm code and\r\n// used to access the (too-powerful) primal-realm Error object.\r\n\r\nexport function throwTantrum(s, err = undefined) {\r\n  const msg = `please report internal shim error: ${s}`;\r\n\r\n  // we want to log these 'should never happen' things.\r\n  // eslint-disable-next-line no-console\r\n  console.error(msg);\r\n  if (err) {\r\n    // eslint-disable-next-line no-console\r\n    console.error(`${err}`);\r\n    // eslint-disable-next-line no-console\r\n    console.error(`${err.stack}`);\r\n  }\r\n\r\n  // eslint-disable-next-line no-debugger\r\n  debugger;\r\n  throw msg;\r\n}\r\n\r\nexport function assert(condition, message) {\r\n  if (!condition) {\r\n    throwTantrum(message);\r\n  }\r\n}\r\n\r\n// Remove code modifications.\r\nexport function cleanupSource(src) {\r\n  /* START_TESTS_ONLY */\r\n\r\n  // Restore eval which is modified by esm module.\r\n  src = src.replace(/\\(0,[^)]+\\)/g, '(0, eval)');\r\n\r\n  // Remove code coverage which is injected by nyc module.\r\n  src = src.replace(/cov_[^+]+\\+\\+[;,]/g, '');\r\n\r\n  /* END_TESTS_ONLY */\r\n  return src;\r\n}\r\n","import { cleanupSource } from './utilities';\r\n\r\n// buildChildRealm is immediately turned into a string, and this function is\r\n// never referenced again, because it closes over the wrong intrinsics\r\n\r\nexport function buildChildRealm(unsafeRec, BaseRealm) {\r\n  const { initRootRealm, initCompartment, getRealmGlobal, realmEvaluate } = BaseRealm;\r\n\r\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\r\n  // code has been run or had a chance to manipulate them. We extract these\r\n  // properties for brevity, not for security. Don't ever run this function\r\n  // *after* user code has had a chance to pollute its environment, or it\r\n  // could be used to gain access to BaseRealm and primal-realm Error\r\n  // objects.\r\n  const { create, defineProperties } = Object;\r\n\r\n  const errorConstructors = new Map([\r\n    ['EvalError', EvalError],\r\n    ['RangeError', RangeError],\r\n    ['ReferenceError', ReferenceError],\r\n    ['SyntaxError', SyntaxError],\r\n    ['TypeError', TypeError],\r\n    ['URIError', URIError]\r\n  ]);\r\n\r\n  // Like Realm.apply except that it catches anything thrown and rethrows it\r\n  // as an Error from this realm\r\n  function callAndWrapError(target, ...args) {\r\n    try {\r\n      return target(...args);\r\n    } catch (err) {\r\n      if (Object(err) !== err) {\r\n        // err is a primitive value, which is safe to rethrow\r\n        throw err;\r\n      }\r\n      let eName, eMessage, eStack;\r\n      try {\r\n        // The child environment might seek to use 'err' to reach the\r\n        // parent's intrinsics and corrupt them. `${err.name}` will cause\r\n        // string coercion of 'err.name'. If err.name is an object (probably\r\n        // a String of the parent Realm), the coercion uses\r\n        // err.name.toString(), which is under the control of the parent. If\r\n        // err.name were a primitive (e.g. a number), it would use\r\n        // Number.toString(err.name), using the child's version of Number\r\n        // (which the child could modify to capture its argument for later\r\n        // use), however primitives don't have properties like .prototype so\r\n        // they aren't useful for an attack.\r\n        eName = `${err.name}`;\r\n        eMessage = `${err.message}`;\r\n        eStack = `${err.stack}`;\r\n        // eName/eMessage/eStack are now child-realm primitive strings, and\r\n        // safe to expose\r\n      } catch (ignored) {\r\n        // if err.name.toString() throws, keep the (parent realm) Error away\r\n        // from the child\r\n        throw new Error('unknown error');\r\n      }\r\n      const ErrorConstructor = errorConstructors.get(eName) || Error;\r\n      try {\r\n        throw new ErrorConstructor(eMessage);\r\n      } catch (err2) {\r\n        err2.stack = eStack; // replace with the captured inner stack\r\n        throw err2;\r\n      }\r\n    }\r\n  }\r\n\r\n  class Realm {\r\n    constructor() {\r\n      // The Realm constructor is not intended to be used with the new operator\r\n      // or to be subclassed. It may be used as the value of an extends clause\r\n      // of a class definition but a super call to the Realm constructor will\r\n      // cause an exception.\r\n\r\n      // When Realm is called as a function, an exception is also raised because\r\n      // a class constructor cannot be invoked without 'new'.\r\n      throw new TypeError('Realm is not a constructor');\r\n    }\r\n\r\n    static makeRootRealm(options) {\r\n      // This is the exposed interface.\r\n      options = Object(options); // todo: sanitize\r\n\r\n      // Bypass the constructor.\r\n      const r = create(Realm.prototype);\r\n      callAndWrapError(initRootRealm, unsafeRec, r, options);\r\n      return r;\r\n    }\r\n\r\n    static makeCompartment() {\r\n      // Bypass the constructor.\r\n      const r = create(Realm.prototype);\r\n      callAndWrapError(initCompartment, unsafeRec, r);\r\n      return r;\r\n    }\r\n\r\n    // we omit the constructor because it is empty. All the personalization\r\n    // takes place in one of the two static methods,\r\n    // makeRootRealm/makeCompartment\r\n\r\n    get global() {\r\n      // this is safe against being called with strange 'this' because\r\n      // baseGetGlobal immediately does a trademark check (it fails unless\r\n      // this 'this' is present in a weakmap that is only populated with\r\n      // legitimate Realm instances)\r\n      return callAndWrapError(getRealmGlobal, this);\r\n    }\r\n\r\n    evaluate(x, endowments) {\r\n      // safe against strange 'this', as above\r\n      return callAndWrapError(realmEvaluate, this, x, endowments);\r\n    }\r\n  }\r\n\r\n  defineProperties(Realm, {\r\n    toString: {\r\n      value: () => 'function Realm() { [shim code] }',\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: true\r\n    }\r\n  });\r\n\r\n  defineProperties(Realm.prototype, {\r\n    toString: {\r\n      value: () => '[object Realm]',\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: true\r\n    }\r\n  });\r\n\r\n  return Realm;\r\n}\r\n\r\n// The parentheses means we don't bind the 'buildChildRealm' name inside the\r\n// child's namespace. this would accept an anonymous function declaration.\r\n// function expression (not a declaration) so it has a completion value.\r\nconst buildChildRealmString = cleanupSource(`'use strict'; (${buildChildRealm})`);\r\n\r\nexport function createRealmFacade(unsafeRec, BaseRealm) {\r\n  const { unsafeEval } = unsafeRec;\r\n\r\n  // The BaseRealm is the Realm class created by\r\n  // the shim. It's only valid for the context where\r\n  // it was parsed.\r\n\r\n  // The Realm facade is a lightweight class built in the\r\n  // context a different context, that provide a fully\r\n  // functional Realm class using the intrisics\r\n  // of that context.\r\n\r\n  // This process is simplified because all methods\r\n  // and properties on a realm instance already return\r\n  // values using the intrinsics of the realm's context.\r\n\r\n  // Invoke the BaseRealm constructor with Realm as the prototype.\r\n  return unsafeEval(buildChildRealmString)(unsafeRec, BaseRealm);\r\n}\r\n","import { getOwnPropertyDescriptor } from './commons';\r\nimport { assert } from './utilities';\r\n\r\n// All the following stdlib items have the same name on both our intrinsics\r\n// object and on the global object. Unlike Infinity/NaN/undefined, these\r\n// should all be writable and configurable.\r\nconst sharedGlobalPropertyNames = [\r\n  // *** 18.2 Function Properties of the Global Object\r\n\r\n  // 'eval', // comes from safeEval instead\r\n  'isFinite',\r\n  'isNaN',\r\n  'parseFloat',\r\n  'parseInt',\r\n\r\n  'decodeURI',\r\n  'decodeURIComponent',\r\n  'encodeURI',\r\n  'encodeURIComponent',\r\n\r\n  // *** 18.3 Constructor Properties of the Global Object\r\n\r\n  'Array',\r\n  'ArrayBuffer',\r\n  'Boolean',\r\n  'DataView',\r\n  'Date',\r\n  'Error',\r\n  'EvalError',\r\n  'Float32Array',\r\n  'Float64Array',\r\n  // 'Function', // comes from safeFunction instead\r\n  'Int8Array',\r\n  'Int16Array',\r\n  'Int32Array',\r\n  'Map',\r\n  'Number',\r\n  'Object',\r\n  'Promise',\r\n  'Proxy',\r\n  'RangeError',\r\n  'ReferenceError',\r\n  'RegExp',\r\n  'Set',\r\n  // 'SharedArrayBuffer' // removed on Jan 5, 2018\r\n  'String',\r\n  'Symbol',\r\n  'SyntaxError',\r\n  'TypeError',\r\n  'Uint8Array',\r\n  'Uint8ClampedArray',\r\n  'Uint16Array',\r\n  'Uint32Array',\r\n  'URIError',\r\n  'WeakMap',\r\n  'WeakSet',\r\n\r\n  // *** 18.4 Other Properties of the Global Object\r\n\r\n  // 'Atomics', // removed on Jan 5, 2018\r\n  'JSON',\r\n  'Math',\r\n  'Reflect',\r\n\r\n  // *** Annex B\r\n\r\n  'escape',\r\n  'unescape',\r\n\r\n  // *** ECMA-402\r\n\r\n  'Intl'\r\n\r\n  // *** ESNext\r\n\r\n  // 'Realm' // Comes from createRealmGlobalObject()\r\n];\r\n\r\nexport function getSharedGlobalDescs(unsafeGlobal) {\r\n  const descriptors = {\r\n    // *** 18.1 Value Properties of the Global Object\r\n    Infinity: { value: Infinity },\r\n    NaN: { value: NaN },\r\n    undefined: { value: undefined }\r\n  };\r\n\r\n  for (const name of sharedGlobalPropertyNames) {\r\n    const desc = getOwnPropertyDescriptor(unsafeGlobal, name);\r\n    if (desc) {\r\n      // Abort if an accessor is found on the unsafe global object instead of a\r\n      // data property. We should never get into this non standard situation.\r\n      assert('value' in desc, `unexpected accessor on global property: ${name}`);\r\n\r\n      descriptors[name] = {\r\n        value: desc.value,\r\n        writable: true,\r\n        configurable: true\r\n      };\r\n    }\r\n  }\r\n\r\n  return descriptors;\r\n}\r\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\r\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\r\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\r\n\r\n/**\r\n * Replace the legacy accessors of Object to comply with strict mode\r\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\r\n *\r\n * todo: list the issues resolved\r\n *\r\n * This function can be used in two ways: (1) invoked directly to fix the primal\r\n * realm's Object.prototype, and (2) converted to a string to be executed\r\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\r\n * the function to have no dependencies, so don't import anything from the outside.\r\n */\r\n\r\n// todo: this file should be moved out to a separate repo and npm module.\r\nexport function repairAccessors() {\r\n  const {\r\n    defineProperty,\r\n    defineProperties,\r\n    getOwnPropertyDescriptor,\r\n    getPrototypeOf,\r\n    prototype: objectPrototype\r\n  } = Object;\r\n\r\n  // On some platforms, the implementation of these functions act as if they are\r\n  // in sloppy mode: if they're invoked badly, they will expose the global object,\r\n  // so we need to repair these for security. Thus it is our responsibility to fix\r\n  // this, and we need to include repairAccessors. E.g. Chrome in 2016.\r\n\r\n  try {\r\n    // Verify that the method is not callable.\r\n    // eslint-disable-next-line no-restricted-properties, no-underscore-dangle\r\n    (0, objectPrototype.__lookupGetter__)('x');\r\n  } catch (ignore) {\r\n    // Throws, no need to patch.\r\n    return;\r\n  }\r\n\r\n  function toObject(obj) {\r\n    if (obj === undefined || obj === null) {\r\n      throw new TypeError(`can't convert undefined or null to object`);\r\n    }\r\n    return Object(obj);\r\n  }\r\n\r\n  function asPropertyName(obj) {\r\n    if (typeof obj === 'symbol') {\r\n      return obj;\r\n    }\r\n    return `${obj}`;\r\n  }\r\n\r\n  function aFunction(obj, accessor) {\r\n    if (typeof obj !== 'function') {\r\n      throw TypeError(`invalid ${accessor} usage`);\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  defineProperties(objectPrototype, {\r\n    __defineGetter__: {\r\n      value: function __defineGetter__(prop, func) {\r\n        const O = toObject(this);\r\n        defineProperty(O, prop, {\r\n          get: aFunction(func, 'getter'),\r\n          enumerable: true,\r\n          configurable: true\r\n        });\r\n      }\r\n    },\r\n    __defineSetter__: {\r\n      value: function __defineSetter__(prop, func) {\r\n        const O = toObject(this);\r\n        defineProperty(O, prop, {\r\n          set: aFunction(func, 'setter'),\r\n          enumerable: true,\r\n          configurable: true\r\n        });\r\n      }\r\n    },\r\n    __lookupGetter__: {\r\n      value: function __lookupGetter__(prop) {\r\n        let O = toObject(this);\r\n        prop = asPropertyName(prop);\r\n        let desc;\r\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\r\n          O = getPrototypeOf(O);\r\n        }\r\n        return desc && desc.get;\r\n      }\r\n    },\r\n    __lookupSetter__: {\r\n      value: function __lookupSetter__(prop) {\r\n        let O = toObject(this);\r\n        prop = asPropertyName(prop);\r\n        let desc;\r\n        while (O && !(desc = getOwnPropertyDescriptor(O, prop))) {\r\n          O = getPrototypeOf(O);\r\n        }\r\n        return desc && desc.set;\r\n      }\r\n    }\r\n  });\r\n}\r\n","// Adapted from SES/Caja\r\n// Copyright (C) 2011 Google Inc.\r\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\r\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\r\n\r\n/**\r\n * This block replaces the original Function constructor, and the original\r\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\r\n * safe replacements that throw if invoked.\r\n *\r\n * These are all reachable via syntax, so it isn't sufficient to just\r\n * replace global properties with safe versions. Our main goal is to prevent\r\n * access to the Function constructor through these starting points.\r\n\r\n * After this block is done, the originals must no longer be reachable, unless\r\n * a copy has been made, and funtions can only be created by syntax (using eval)\r\n * or by invoking a previously saved reference to the originals.\r\n */\r\n\r\n// todo: this file should be moved out to a separate repo and npm module.\r\nexport function repairFunctions() {\r\n  const { defineProperties, getPrototypeOf, setPrototypeOf } = Object;\r\n\r\n  /**\r\n   * The process to repair constructors:\r\n   * 1. Create an instance of the function by evaluating syntax\r\n   * 2. Obtain the prototype from the instance\r\n   * 3. Create a substitute tamed constructor\r\n   * 4. Replace the original constructor with the tamed constructor\r\n   * 5. Replace tamed constructor prototype property with the original one\r\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\r\n   */\r\n  function repairFunction(name, declaration) {\r\n    let FunctionInstance;\r\n    try {\r\n      // eslint-disable-next-line no-new-func\r\n      FunctionInstance = (0, eval)(declaration);\r\n    } catch (e) {\r\n      if (e instanceof SyntaxError) {\r\n        // Prevent failure on platforms where async and/or generators are not supported.\r\n        return;\r\n      }\r\n      // Re-throw\r\n      throw e;\r\n    }\r\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\r\n\r\n    // Prevents the evaluation of source when calling constructor on the prototype of functions.\r\n    // eslint-disable-next-line no-new-func\r\n    const TamedFunction = Function('throw new TypeError(\"Not available\");');\r\n    defineProperties(TamedFunction, { name: { value: name } });\r\n\r\n    // (new Error()).constructors does not inherit from Function, because Error\r\n    // was defined before ES6 classes. So we don't need to repair it too.\r\n\r\n    // (Error()).constructor inherit from Function, which gets a tamed constructor here.\r\n\r\n    // todo: in an ES6 class that does not inherit from anything, what does its\r\n    // constructor inherit from? We worry that it inherits from Function, in\r\n    // which case instances could give access to unsafeFunction. markm says\r\n    // we're fine: the constructor inherits from Object.prototype\r\n\r\n    // This line replaces the original constructor in the prototype chain\r\n    // with the tamed one. No copy of the original is peserved.\r\n    defineProperties(FunctionPrototype, { constructor: { value: TamedFunction } });\r\n\r\n    // This line sets the tamed constructor's prototype data property to\r\n    // the original one.\r\n    defineProperties(TamedFunction, { prototype: { value: FunctionPrototype } });\r\n\r\n    if (TamedFunction !== Function.prototype.constructor) {\r\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\r\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\r\n    }\r\n  }\r\n\r\n  // Here, the order of operation is important: Function needs to be repaired\r\n  // first since the other repaired constructors need to inherit from the tamed\r\n  // Function function constructor.\r\n\r\n  // note: this really wants to be part of the standard, because new\r\n  // constructors may be added in the future, reachable from syntax, and this\r\n  // list must be updated to match.\r\n\r\n  // \"plain arrow functions\" inherit from Function.prototype\r\n\r\n  repairFunction('Function', '(function(){})');\r\n  repairFunction('GeneratorFunction', '(function*(){})');\r\n  repairFunction('AsyncFunction', '(async function(){})');\r\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\r\n}\r\n","// this module must never be importable outside the Realm shim itself\r\nimport { getSharedGlobalDescs } from './stdlib';\r\nimport { repairAccessors } from './repair/accessors';\r\nimport { repairFunctions } from './repair/functions';\r\nimport { cleanupSource } from './utilities';\r\nimport { freeze } from './commons';\r\n\r\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\r\n// We need this to implement the shim. However, when Realms land for real,\r\n// this feature will be provided by the underlying engine instead.\r\n\r\n// Platform detection.\r\nconst isNode =\r\n  typeof process === 'object' &&\r\n  process.browser !== true &&\r\n  typeof exports === 'object' &&\r\n  typeof module !== 'undefined';\r\nconst isBrowser =\r\n  (typeof process === 'object' && process.browser === true) || typeof document === 'object';\r\nif ((!isNode && !isBrowser) || (isNode && isBrowser)) {\r\n  throw new Error('unexpected platform, unable to create Realm');\r\n}\r\nconst vm = isNode ? require('vm') : undefined;\r\n\r\n// note: in a node module, the top-level 'this' is not the global object\r\n// (it's *something* but we aren't sure what), however an indirect eval of\r\n// 'this' will be the correct global object.\r\n\r\nconst unsafeGlobalSrc = \"'use strict'; this\";\r\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\r\n\r\n// This method is only exported for testing purposes.\r\nexport function createNewUnsafeGlobalForNode() {\r\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\r\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\r\n\r\n  return unsafeGlobal;\r\n}\r\n\r\n// This method is only exported for testing purposes.\r\nexport function createNewUnsafeGlobalForBrowser() {\r\n  const iframe = document.createElement('iframe');\r\n  iframe.style.display = 'none';\r\n\r\n  document.body.appendChild(iframe);\r\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\r\n\r\n  // We keep the iframe attached to the DOM because removing it\r\n  // causes its global object to lose intrinsics, its eval()\r\n  // function to evaluate code, etc.\r\n\r\n  // TODO: can we remove and garbage-collect the iframes?\r\n\r\n  return unsafeGlobal;\r\n}\r\n\r\nconst getNewUnsafeGlobal = isNode ? createNewUnsafeGlobalForNode : createNewUnsafeGlobalForBrowser;\r\n\r\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\r\n// set of intrinsics together with their associated eval and Function\r\n// evaluators. These must be used as a matched set, since the evaluators are\r\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\r\n// mix-and-match them from different contexts, that would enable some\r\n// attacks.\r\nfunction createUnsafeRec(unsafeGlobal, allShims = []) {\r\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\r\n\r\n  return freeze({\r\n    unsafeGlobal,\r\n    sharedGlobalDescs,\r\n    unsafeEval: unsafeGlobal.eval,\r\n    unsafeFunction: unsafeGlobal.Function,\r\n    allShims\r\n  });\r\n}\r\n\r\nconst repairAccessorsShim = cleanupSource(`\"use strict\"; (${repairAccessors})();`);\r\nconst repairFunctionsShim = cleanupSource(`\"use strict\"; (${repairFunctions})();`);\r\n\r\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\r\n// new global object\r\nexport function createNewUnsafeRec(allShims) {\r\n  const unsafeGlobal = getNewUnsafeGlobal();\r\n  unsafeGlobal.eval(repairAccessorsShim);\r\n  unsafeGlobal.eval(repairFunctionsShim);\r\n  return createUnsafeRec(unsafeGlobal, allShims);\r\n}\r\n\r\n// Create a new unsafeRec from the current context, where the Realm shim is\r\n// being parsed and executed, aka the \"Primal Realm\"\r\nexport function createCurrentUnsafeRec() {\r\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\r\n  repairAccessors();\r\n  repairFunctions();\r\n  return createUnsafeRec(unsafeGlobal);\r\n}\r\n","import {\r\n  arrayFilter,\r\n  getOwnPropertyDescriptors,\r\n  getOwnPropertyNames,\r\n  objectHasOwnProperty,\r\n  regexpTest\r\n} from './commons';\r\n\r\n// todo: think about how this interacts with endowments, check for conflicts\r\n// between the names being optimized and the ones added by endowments\r\n\r\n/**\r\n * Simplified validation of indentifier names: may only contain alphanumeric\r\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\r\n * and does not reduces the compatibility of the shim. The motivation for\r\n * this limitation was to decrease the complexity of the implementation,\r\n * and to maintain a resonable level of performance.\r\n * Note: \\w is equivalent [a-zA-Z_0-9]\r\n * See 11.6.1 Identifier Names\r\n */\r\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\r\n\r\n/**\r\n * In JavaScript you cannot use these reserved words as variables.\r\n * See 11.6.1 Identifier Names\r\n */\r\nconst keywords = new Set([\r\n  // 11.6.2.1 Keywords\r\n  'await',\r\n  'break',\r\n  'case',\r\n  'catch',\r\n  'class',\r\n  'const',\r\n  'continue',\r\n  'debugger',\r\n  'default',\r\n  'delete',\r\n  'do',\r\n  'else',\r\n  'export',\r\n  'extends',\r\n  'finally',\r\n  'for',\r\n  'function',\r\n  'if',\r\n  'import',\r\n  'in',\r\n  'instanceof',\r\n  'new',\r\n  'return',\r\n  'super',\r\n  'switch',\r\n  'this',\r\n  'throw',\r\n  'try',\r\n  'typeof',\r\n  'var',\r\n  'void',\r\n  'while',\r\n  'with',\r\n  'yield',\r\n\r\n  // Also reserved when parsing strict mode code\r\n  'let',\r\n  'static',\r\n\r\n  // 11.6.2.2 Future Reserved Words\r\n  'enum',\r\n\r\n  // Also reserved when parsing strict mode code\r\n  'implements',\r\n  'package',\r\n  'protected',\r\n  'interface',\r\n  'private',\r\n  'public',\r\n\r\n  // Reserved but not mentioned in specs\r\n  'await',\r\n\r\n  'null',\r\n  'true',\r\n  'false',\r\n\r\n  'this',\r\n  'arguments'\r\n]);\r\n\r\n/**\r\n * getOptimizableGlobals()\r\n * What variable names might it bring into scope? These include all\r\n * property names which can be variable names, including the names\r\n * of inherited properties. It excludes symbols and names which are\r\n * keywords. We drop symbols safely. Currently, this shim refuses\r\n * service if any of the names are keywords or keyword-like. This is\r\n * safe and only prevent performance optimization.\r\n */\r\nexport function getOptimizableGlobals(safeGlobal) {\r\n  const descs = getOwnPropertyDescriptors(safeGlobal);\r\n\r\n  // getOwnPropertyNames does ignore Symbols so we don't need this extra check:\r\n  // typeof name === 'string' &&\r\n  const constants = arrayFilter(getOwnPropertyNames(descs), name => {\r\n    // Ensure we have a valid identifier. We use regexpTest rather than\r\n    // /../.test() to guard against the case where RegExp has been poisoned.\r\n    if (name === 'eval' || keywords.has(name) || !regexpTest(identifierPattern, name)) {\r\n      return false;\r\n    }\r\n\r\n    const desc = descs[name];\r\n    return (\r\n      //\r\n      // The getters will not have .writable, don't let the falsyness of\r\n      // 'undefined' trick us: test with === false, not ! . However descriptors\r\n      // inherit from the (potentially poisoned) global object, so we might see\r\n      // extra properties which weren't really there. Accessor properties have\r\n      // 'get/set/enumerable/configurable', while data properties have\r\n      // 'value/writable/enumerable/configurable'.\r\n      desc.configurable === false &&\r\n      desc.writable === false &&\r\n      //\r\n      // Checks for data properties because they're the only ones we can\r\n      // optimize (accessors are most likely non-constant). Descriptors can't\r\n      // can't have accessors and value properties at the same time, therefore\r\n      // this check is sufficient. Using explicit own property deal with the\r\n      // case where Object.prototype has been poisoned.\r\n      objectHasOwnProperty(desc, 'value')\r\n    );\r\n  });\r\n\r\n  return constants;\r\n}\r\n","import { freeze, getPrototypeOf, objectHasOwnProperty } from './commons';\r\nimport { throwTantrum } from './utilities';\r\n\r\n/**\r\n * alwaysThrowHandler is a proxy handler which throws on any trap called.\r\n * It's made from a proxy with a get trap that throws. Its target is\r\n * an immutable (frozen) object and is safe to share.\r\n */\r\nconst alwaysThrowHandler = new Proxy(freeze({}), {\r\n  get(target, prop) {\r\n    throwTantrum(`unexpected scope handler trap called: ${prop}`);\r\n  }\r\n});\r\n\r\n/**\r\n * ScopeHandler manages a Proxy which serves as the global scope for the\r\n * safeEvaluator operation (the Proxy is the argument of a 'with' binding).\r\n * As described in createSafeEvaluator(), it has several functions:\r\n * - allow the very first (and only the very first) use of 'eval' to map to\r\n *   the real (unsafe) eval function, so it acts as a 'direct eval' and can\r\n *    access its lexical scope (which maps to the 'with' binding, which the\r\n *   ScopeHandler also controls).\r\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\r\n *   which lives as the 'eval' property of the safeGlobal.\r\n * - route all other property lookups at the safeGlobal.\r\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\r\n * - ensure the Proxy invariants despite some global properties being frozen.\r\n */\r\nexport function createScopeHandler(unsafeRec) {\r\n  const { unsafeGlobal, unsafeEval } = unsafeRec;\r\n\r\n  // This flag allow us to determine if the eval() call is an done by the\r\n  // realm's code or if it is user-land invocation, so we can react differently.\r\n  let useUnsafeEvaluator = false;\r\n\r\n  return {\r\n    // The scope handler throws if any trap other than get/set/has are run\r\n    // (e.g. getOwnPropertyDescriptors, apply, getPrototypeOf).\r\n    // eslint-disable-next-line no-proto\r\n    __proto__: alwaysThrowHandler,\r\n\r\n    allowUnsafeEvaluatorOnce() {\r\n      useUnsafeEvaluator = true;\r\n    },\r\n\r\n    unsafeEvaluatorAllowed() {\r\n      return useUnsafeEvaluator;\r\n    },\r\n\r\n    get(target, prop) {\r\n      // Special treatment for eval. The very first lookup of 'eval' gets the\r\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\r\n      // the 'with' context.\r\n      if (prop === 'eval') {\r\n        // test that it is true rather than merely truthy\r\n        if (useUnsafeEvaluator === true) {\r\n          // revoke before use\r\n          useUnsafeEvaluator = false;\r\n          return unsafeEval;\r\n        }\r\n        return target.eval;\r\n      }\r\n\r\n      // todo: shim integrity, capture Symbol.unscopables\r\n      if (prop === Symbol.unscopables) {\r\n        // Safe to return a primal realm Object here because the only code that\r\n        // can do a get() on a non-string is the internals of with() itself,\r\n        // and the only thing it does is to look for properties on it. User\r\n        // code cannot do a lookup on non-strings.\r\n        return undefined;\r\n      }\r\n\r\n      // Properties of the global.\r\n      if (prop in target) {\r\n        return target[prop];\r\n      }\r\n\r\n      // Prevent the lookup for other properties.\r\n      return undefined;\r\n    },\r\n\r\n    // eslint-disable-next-line class-methods-use-this\r\n    set(target, prop, value) {\r\n      // todo: allow modifications when target.hasOwnProperty(prop) and it\r\n      // is writable, assuming we've already rejected overlap (see\r\n      // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\r\n      // target[prop] = value\r\n      if (objectHasOwnProperty(target, prop)) {\r\n        // todo: shim integrity: TypeError, String\r\n        throw new TypeError(`do not modify endowments like ${String(prop)}`);\r\n      }\r\n\r\n      // todo (optimization): keep a reference to the shadow avoids calling\r\n      // getPrototypeOf on the target every time the set trap is invoked,\r\n      // since safeGlobal === getPrototypeOf(target).\r\n      getPrototypeOf(target)[prop] = value;\r\n\r\n      // Return true after successful set.\r\n      return true;\r\n    },\r\n\r\n    // we need has() to return false for some names to prevent the lookup  from\r\n    // climbing the scope chain and eventually reaching the unsafeGlobal\r\n    // object, which is bad.\r\n\r\n    // note: unscopables! every string in Object[Symbol.unscopables]\r\n\r\n    // todo: we'd like to just have has() return true for everything, and then\r\n    // use get() to raise a ReferenceError for anything not on the safe global.\r\n    // But we want to be compatible with ReferenceError in the normal case and\r\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\r\n    // distinguish these two cases (the trap behavior might be different), or\r\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\r\n    // to XXX. We already need a mandatory parse to prevent the 'import',\r\n    // since it's a special form instead of merely being a global variable/\r\n\r\n    // note: if we make has() return true always, then we must implement a\r\n    // set() trap to avoid subverting the protection of strict mode (it would\r\n    // accept assignments to undefined globals, when it ought to throw\r\n    // ReferenceError for such assignments)\r\n\r\n    has(target, prop) {\r\n      // proxies stringify 'prop', so no TOCTTOU danger here\r\n\r\n      // unsafeGlobal: hide all properties of unsafeGlobal at the expense of 'typeof'\r\n      // being wrong for those properties. For example, in the browser, evaluating\r\n      // 'document = 3', will add a property to  safeGlobal instead of throwing a\r\n      // ReferenceError.\r\n      if (prop === 'eval' || prop in target || prop in unsafeGlobal) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n  };\r\n}\r\n","// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\r\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\r\n// whitespace by the parser, but not matched by /\\s/, then this would admit\r\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\r\n// something like that from something like importnotreally('power.js') which\r\n// is perfectly safe.\r\n\r\nconst importParser = /^(.*)\\bimport\\s*(\\(|\\/\\/|\\/\\*)/m;\r\n\r\nexport function rejectImportExpressions(s) {\r\n  const matches = importParser.exec(s);\r\n  if (matches) {\r\n    // todo: if we have a full parser available, use it here. If there is no\r\n    // 'import' token in the string, we're safe.\r\n    // if (!parse(s).contains('import')) return;\r\n    const linenum = matches[1].split('\\n').length; // more or less\r\n    throw new SyntaxError(`possible import expression rejected around line ${linenum}`);\r\n  }\r\n}\r\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\r\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\r\n\r\nimport {\r\n  apply,\r\n  arrayJoin,\r\n  arrayPop,\r\n  create,\r\n  defineProperties,\r\n  getOwnPropertyDescriptors,\r\n  getPrototypeOf,\r\n  regexpTest,\r\n  setPrototypeOf,\r\n  stringIncludes\r\n} from './commons';\r\nimport { getOptimizableGlobals } from './optimizer';\r\nimport { createScopeHandler } from './scopeHandler';\r\nimport { rejectImportExpressions } from './sourceParser';\r\nimport { assert, throwTantrum } from './utilities';\r\n\r\nfunction buildOptimizer(constants) {\r\n  // No need to build an oprimizer when there are no constants.\r\n  if (constants.length === 0) return '';\r\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\r\n  // since the optimizer only needs references to the safe global.\r\n  return `const {${arrayJoin(constants, ',')}} = this;`;\r\n}\r\n\r\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\r\n  const { unsafeFunction } = unsafeRec;\r\n\r\n  const optimizer = buildOptimizer(constants);\r\n\r\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\r\n  // a function in strict mode that evaluates the provided code using direct\r\n  // eval, and thus in strict mode in the same scope. We must be very careful\r\n  // to not create new names in this scope\r\n\r\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\r\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\r\n  // 2: 'optimizer' catches common variable names for speed\r\n  // 3: The inner strict function is effectively passed two parameters:\r\n  //    a) its arguments[0] is the source to be directly evaluated.\r\n  //    b) its 'this' is the this binding seen by the code being directly evaluated.\r\n\r\n  // everything in the 'optimizer' string is looked up in the proxy\r\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\r\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\r\n  // up in the proxy, that's the first time it is looked up after\r\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\r\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\r\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\r\n  // looked up in the context of the inner function. The *contents* of\r\n  // arguments[0], because we're using direct eval, are looked up in the\r\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\r\n  // back to 'false', so any instances of 'eval' in that string will get the\r\n  // safe evaluator.\r\n\r\n  return unsafeFunction(`\r\n    with (arguments[0]) {\r\n      ${optimizer}\r\n      return function() {\r\n        'use strict';\r\n        return eval(arguments[0]);\r\n      };\r\n    }\r\n  `);\r\n}\r\n\r\nexport function createSafeEvaluatorFactory(unsafeRec, safeGlobal) {\r\n  const { unsafeFunction } = unsafeRec;\r\n\r\n  const scopeHandler = createScopeHandler(unsafeRec);\r\n  const optimizableGlobals = getOptimizableGlobals(safeGlobal);\r\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(unsafeRec, optimizableGlobals);\r\n\r\n  function factory(endowments = {}) {\r\n    // todo (shim limitation): scan endowments, throw error if endowment\r\n    // overlaps with the const optimization (which would otherwise\r\n    // incorrectly shadow endowments), or if endowments includes 'eval'. Also\r\n    // prohibit accessor properties (to be able to consistently explain\r\n    // things in terms of shimming the global lexical scope).\r\n    // writeable-vs-nonwritable == let-vs-const, but there's no\r\n    // global-lexical-scope equivalent of an accessor, outside what we can\r\n    // explain/spec\r\n    const scopeTarget = create(safeGlobal, getOwnPropertyDescriptors(endowments));\r\n    const scopeProxy = new Proxy(scopeTarget, scopeHandler);\r\n    const scopedEvaluator = apply(scopedEvaluatorFactory, safeGlobal, [scopeProxy]);\r\n\r\n    // We use the the concise method syntax to create an eval without a\r\n    // [[Construct]] behavior (such that the invocation \"new eval()\" throws\r\n    // TypeError: eval is not a constructor\"), but which still accepts a\r\n    // 'this' binding.\r\n    const safeEval = {\r\n      eval(src) {\r\n        src = `${src}`;\r\n        rejectImportExpressions(src);\r\n        scopeHandler.allowUnsafeEvaluatorOnce();\r\n        let err;\r\n        try {\r\n          // Ensure that \"this\" resolves to the safe global.\r\n          return apply(scopedEvaluator, safeGlobal, [src]);\r\n        } catch (e) {\r\n          // stash the child-code error in hopes of debugging the internal failure\r\n          err = e;\r\n          throw e;\r\n        } finally {\r\n          // belt and suspenders: the proxy switches this off immediately after\r\n          // the first access, but if that's not the case we abort.\r\n          if (scopeHandler.unsafeEvaluatorAllowed()) {\r\n            throwTantrum('handler did not revoke useUnsafeEvaluator', err);\r\n          }\r\n        }\r\n      }\r\n    }.eval;\r\n\r\n    // safeEval's prototype is currently the primal realm's\r\n    // Function.prototype, which we must not let escape. To make 'eval\r\n    // instanceof Function' be true inside the realm, we need to point it at\r\n    // the RootRealm's value.\r\n\r\n    // Ensure that eval from any compartment in a root realm is an instance\r\n    // of Function in any compartment of the same root realm.\r\n    setPrototypeOf(safeEval, unsafeFunction.prototype);\r\n\r\n    assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\r\n    assert(getPrototypeOf(safeEval).constructor !== unsafeFunction, 'hide unsafeFunction');\r\n\r\n    // note: be careful to not leak our primal Function.prototype by setting\r\n    // this to a plain arrow function. Now that we have safeEval, use it.\r\n    defineProperties(safeEval, {\r\n      toString: {\r\n        value: safeEval(\"() => 'function eval() { [shim code] }'\"),\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: true\r\n      }\r\n    });\r\n\r\n    return safeEval;\r\n  }\r\n\r\n  return factory;\r\n}\r\n\r\nexport function createSafeEvaluator(safeEvaluatorFactory) {\r\n  return safeEvaluatorFactory();\r\n}\r\n\r\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\r\n  return (x, endowments) => safeEvaluatorFactory(endowments)(x);\r\n}\r\n\r\n/**\r\n * A safe version of the native Function which relies on\r\n * the safety of evalEvaluator for confinement.\r\n */\r\nexport function createFunctionEvaluator(unsafeRec, safeEval) {\r\n  const { unsafeFunction, unsafeGlobal } = unsafeRec;\r\n\r\n  const safeFunction = function Function(...params) {\r\n    const functionBody = `${arrayPop(params) || ''}`;\r\n    let functionParams = `${arrayJoin(params, ',')}`;\r\n    if (!regexpTest(/^[\\w\\s,]*$/, functionParams)) {\r\n      throw new unsafeGlobal.SyntaxError(\r\n        'shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names'\r\n      );\r\n      // this protects against Matt Austin's clever attack:\r\n      // Function(\"arg=`\", \"/*body`){});({x: this/**/\")\r\n      // which would turn into\r\n      //     (function(arg=`\r\n      //     /*``*/){\r\n      //      /*body`){});({x: this/**/\r\n      //     })\r\n      // which parses as a default argument of `\\n/*``*/){\\n/*body` , which\r\n      // is a pair of template literals back-to-back (so the first one\r\n      // nominally evaluates to the parser to use on the second one), which\r\n      // can't actually execute (because the first literal evals to a string,\r\n      // which can't be a parser function), but that doesn't matter because\r\n      // the function is bypassed entirely. When that gets evaluated, it\r\n      // defines (but does not invoke) a function, then evaluates a simple\r\n      // {x: this} expression, giving access to the safe global.\r\n    }\r\n\r\n    // Is this a real functionBody, or is someone attempting an injection\r\n    // attack? This will throw a SyntaxError if the string is not actually a\r\n    // function body. We coerce the body into a real string above to prevent\r\n    // someone from passing an object with a toString() that returns a safe\r\n    // string the first time, but an evil string the second time.\r\n    // eslint-disable-next-line no-new, new-cap\r\n    new unsafeFunction(functionBody);\r\n\r\n    if (stringIncludes(functionParams, ')')) {\r\n      // If the formal parameters string include ) - an illegal\r\n      // character - it may make the combined function expression\r\n      // compile. We avoid this problem by checking for this early on.\r\n\r\n      // note: v8 throws just like this does, but chrome accepts e.g. 'a = new Date()'\r\n      throw new unsafeGlobal.SyntaxError(\r\n        'shim limitation: Function arg string contains parenthesis'\r\n      );\r\n      // todo: shim integrity threat if they change SyntaxError\r\n    }\r\n\r\n    // todo: check to make sure this .length is safe. markm says safe.\r\n    if (functionParams.length > 0) {\r\n      // If the formal parameters include an unbalanced block comment, the\r\n      // function must be rejected. Since JavaScript does not allow nested\r\n      // comments we can include a trailing block comment to catch this.\r\n      functionParams += '\\n/*``*/';\r\n    }\r\n\r\n    // todo: fix `this` binding in Function().\r\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\r\n\r\n    return safeEval(src);\r\n  };\r\n\r\n  // Ensure that Function from any compartment in a root realm can be used\r\n  // with instance checks in any compartment of the same root realm.\r\n  setPrototypeOf(safeFunction, unsafeFunction.prototype);\r\n\r\n  assert(getPrototypeOf(safeFunction).constructor !== Function, 'hide Function');\r\n  assert(getPrototypeOf(safeFunction).constructor !== unsafeFunction, 'hide unsafeFunction');\r\n\r\n  defineProperties(safeFunction, {\r\n    // Ensure that any function created in any compartment in a root realm is an\r\n    // instance of Function in any compartment of the same root ralm.\r\n    prototype: { value: unsafeFunction.prototype },\r\n\r\n    // Provide a custom output without overwriting the Function.prototype.toString\r\n    // which is called by some third-party libraries.\r\n    toString: {\r\n      value: safeEval(\"() => 'function Function() { [shim code] }'\"),\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: true\r\n    }\r\n  });\r\n\r\n  return safeFunction;\r\n}\r\n","import { createRealmFacade, buildChildRealm } from './realmFacade';\r\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\r\nimport {\r\n  createSafeEvaluatorFactory,\r\n  createSafeEvaluator,\r\n  createSafeEvaluatorWhichTakesEndowments,\r\n  createFunctionEvaluator\r\n} from './evaluators';\r\nimport { assert } from './utilities';\r\nimport { create, defineProperties, freeze, arrayConcat } from './commons';\r\n\r\n// Mimic private members on the realm instances.\r\n// We define it in the same module and do not export it.\r\nconst RealmRecForRealmInstance = new WeakMap();\r\n\r\nfunction getRealmRecForRealmInstance(realm) {\r\n  // Detect non-objects.\r\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\r\n  // Realm instance has no realmRec. Should not proceed.\r\n  assert(RealmRecForRealmInstance.has(realm), 'Realm instance has no record');\r\n\r\n  return RealmRecForRealmInstance.get(realm);\r\n}\r\n\r\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\r\n  // Detect non-objects.\r\n  assert(Object(realm) === realm, 'bad object, not a Realm instance');\r\n  // Attempt to change an existing realmRec on a realm instance. Should not proceed.\r\n  assert(!RealmRecForRealmInstance.has(realm), 'Realm instance already has a record');\r\n\r\n  RealmRecForRealmInstance.set(realm, realmRec);\r\n}\r\n\r\n// Initialize the global variables for the new Realm.\r\nfunction setDefaultBindings(sharedGlobalDescs, safeGlobal, safeEval, safeFunction) {\r\n  defineProperties(safeGlobal, sharedGlobalDescs);\r\n\r\n  defineProperties(safeGlobal, {\r\n    eval: {\r\n      value: safeEval,\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    Function: {\r\n      value: safeFunction,\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n}\r\n\r\nfunction createRealmRec(unsafeRec) {\r\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\r\n\r\n  const safeGlobal = create(unsafeGlobal.Object.prototype);\r\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(unsafeRec, safeGlobal);\r\n  const safeEval = createSafeEvaluator(safeEvaluatorFactory);\r\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\r\n    safeEvaluatorFactory\r\n  );\r\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEval);\r\n\r\n  setDefaultBindings(sharedGlobalDescs, safeGlobal, safeEval, safeFunction);\r\n\r\n  const realmRec = freeze({\r\n    safeGlobal,\r\n    safeEval,\r\n    safeEvalWhichTakesEndowments,\r\n    safeFunction\r\n  });\r\n\r\n  return realmRec;\r\n}\r\n\r\n/**\r\n * A root realm uses a fresh set of new intrinics. Here we first create\r\n * a new unsafe record, which inherits the shims. Then we proceed with\r\n * the creation of the realm record, and we apply the shims.\r\n */\r\nfunction initRootRealm(parentUnsafeRec, self, options) {\r\n  // note: 'self' is the instance of the Realm.\r\n\r\n  // todo: investigate attacks via Array.species\r\n  // todo: this accepts newShims='string', but it should reject that\r\n  const { shims: newShims } = options;\r\n  const allShims = arrayConcat(parentUnsafeRec.allShims, newShims);\r\n\r\n  // The unsafe record is created already repaired.\r\n  const unsafeRec = createNewUnsafeRec(allShims);\r\n\r\n  // eslint-disable-next-line no-use-before-define\r\n  const Realm = createRealmFacade(unsafeRec, BaseRealm);\r\n\r\n  // Add a Realm descriptor to sharedGlobalDescs, so it can be defined onto the\r\n  // safeGlobal like the rest of the globals.\r\n  unsafeRec.sharedGlobalDescs.Realm = {\r\n    value: Realm,\r\n    writable: true,\r\n    configurable: true\r\n  };\r\n\r\n  // Creating the realmRec provides the global object, eval() and Function()\r\n  // to the realm.\r\n  const realmRec = createRealmRec(unsafeRec);\r\n\r\n  // Apply all shims in the new RootRealm. We don't do this for compartments.\r\n  const { safeEvalWhichTakesEndowments } = realmRec;\r\n  for (const shim of allShims) {\r\n    safeEvalWhichTakesEndowments(shim);\r\n  }\r\n\r\n  // The realmRec acts as a private field on the realm instance.\r\n  registerRealmRecForRealmInstance(self, realmRec);\r\n}\r\n\r\n/**\r\n * A compartment shares the intrinsics of its root realm. Here, only a\r\n * realmRec is necessary to hold the global object, eval() and Function().\r\n */\r\nfunction initCompartment(unsafeRec, self) {\r\n  // note: 'self' is the instance of the Realm.\r\n\r\n  const realmRec = createRealmRec(unsafeRec);\r\n\r\n  // The realmRec acts as a private field on the realm instance.\r\n  registerRealmRecForRealmInstance(self, realmRec);\r\n}\r\n\r\nfunction getRealmGlobal(self) {\r\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\r\n  return safeGlobal;\r\n}\r\n\r\nfunction realmEvaluate(self, x, endowments = {}) {\r\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\r\n  // properties are copied onto the new global 'target'.\r\n  // todo: figure out a way to membrane away the contents to safety.\r\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\r\n  return safeEvalWhichTakesEndowments(x, endowments);\r\n}\r\n\r\nconst BaseRealm = {\r\n  initRootRealm,\r\n  initCompartment,\r\n  getRealmGlobal,\r\n  realmEvaluate\r\n};\r\n\r\n// Create the current unsafeRec from the current \"primal\" environment (the realm\r\n// where the Realm shim is loaded and executed).\r\nconst currentUnsafeRec = createCurrentUnsafeRec();\r\n\r\n/**\r\n * The \"primal\" realm class is defined in the current \"primal\" environment,\r\n * and is part of the shim. There is no need to facade this class via evaluation\r\n * because both share the same intrinsics.\r\n */\r\nconst Realm = buildChildRealm(currentUnsafeRec, BaseRealm);\r\n\r\nexport default Realm;\r\n","// Declare shorthand functions. Sharing these declarations across modules\r\n// improves both consistency and minification. Unused declarations are\r\n// dropped by the tree shaking process.\r\n\r\n// we capture these, not just for brevity, but for security. If any code\r\n// modifies Object to change what 'assign' points to, the Realm shim would be\r\n// corrupted.\r\n\r\nexport const {\r\n  assign,\r\n  create,\r\n  freeze,\r\n  defineProperties, // Object.defineProperty is allowed to fail silentlty, use Object.defineProperties instead.\r\n  getOwnPropertyDescriptor,\r\n  getOwnPropertyDescriptors,\r\n  getOwnPropertyNames,\r\n  getPrototypeOf,\r\n  setPrototypeOf\r\n} = Object;\r\n\r\nexport const {\r\n  apply,\r\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables, unlike Object.keys()\r\n} = Reflect;\r\n\r\n/**\r\n * uncurryThis()\r\n * See http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\r\n * which only lives at http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\r\n *\r\n * Performance:\r\n * 1. The native call is about 10x faster on FF than chrome\r\n * 2. The version using Function.bind() is about 100x slower on FF, equal on chrome, 2x slower on Safari\r\n * 3. The version using a spread and Reflect.apply() is about 10x slower on FF, equal on chrome, 2x slower on Safari\r\n *\r\n * const bind = Function.prototype.bind;\r\n * const uncurryThis = bind.bind(bind.call);\r\n */\r\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\r\n\r\n// We also capture these for security: changes to Array.prototype after the\r\n// Realm shim runs shouldn't affect subsequent Realm operations.\r\nexport const objectHasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty),\r\n  arrayForEach = uncurryThis(Array.prototype.forEach),\r\n  arrayFilter = uncurryThis(Array.prototype.filter),\r\n  arrayPush = uncurryThis(Array.prototype.push),\r\n  arrayPop = uncurryThis(Array.prototype.pop),\r\n  arrayJoin = uncurryThis(Array.prototype.join),\r\n  arrayConcat = uncurryThis(Array.prototype.concat),\r\n  regexpTest = uncurryThis(RegExp.prototype.test),\r\n  stringMatch = uncurryThis(String.prototype.match),\r\n  stringIncludes = uncurryThis(String.prototype.includes);\r\n"],"names":["throwTantrum","s","err","msg","console","error","stack","assert","condition","message","cleanupSource","src","buildChildRealm","unsafeRec","BaseRealm","callAndWrapError","target","args","Object","eName","eMessage","eStack","name","ignored","Error","ErrorConstructor","errorConstructors","get","err2","initRootRealm","initCompartment","getRealmGlobal","realmEvaluate","create","defineProperties","Map","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","Realm","constructor","makeRootRealm","options","r","prototype","makeCompartment","global","evaluate","x","endowments","toString","value","writable","enumerable","configurable","createRealmFacade","unsafeEval","buildChildRealmString","getSharedGlobalDescs","unsafeGlobal","descriptors","Infinity","NaN","undefined","sharedGlobalPropertyNames","desc","getOwnPropertyDescriptor","repairAccessors","toObject","obj","asPropertyName","aFunction","accessor","defineProperty","getPrototypeOf","objectPrototype","__lookupGetter__","ignore","__defineGetter__","prop","func","O","__defineSetter__","set","__lookupSetter__","repairFunctions","repairFunction","declaration","FunctionInstance","eval","e","FunctionPrototype","TamedFunction","Function","setPrototypeOf","createUnsafeRec","allShims","sharedGlobalDescs","freeze","unsafeFunction","createNewUnsafeRec","getNewUnsafeGlobal","repairAccessorsShim","repairFunctionsShim","getOptimizableGlobals","safeGlobal","descs","getOwnPropertyDescriptors","constants","arrayFilter","getOwnPropertyNames","keywords","has","regexpTest","identifierPattern","objectHasOwnProperty","createScopeHandler","useUnsafeEvaluator","__proto__","alwaysThrowHandler","allowUnsafeEvaluatorOnce","unsafeEvaluatorAllowed","Symbol","unscopables","rejectImportExpressions","matches","importParser","exec","linenum","split","length","buildOptimizer","arrayJoin","createScopedEvaluatorFactory","optimizer","createSafeEvaluatorFactory","scopeHandler","optimizableGlobals","scopedEvaluatorFactory","scopeTarget","scopeProxy","Proxy","scopedEvaluator","apply","safeEval","createSafeEvaluator","safeEvaluatorFactory","createSafeEvaluatorWhichTakesEndowments","createFunctionEvaluator","safeFunction","params","functionBody","arrayPop","functionParams","stringIncludes","getRealmRecForRealmInstance","realm","RealmRecForRealmInstance","registerRealmRecForRealmInstance","realmRec","setDefaultBindings","createRealmRec","safeEvalWhichTakesEndowments","assign","ownKeys","Reflect","uncurryThis","fn","thisArg","hasOwnProperty","Array","filter","pop","join","arrayConcat","concat","RegExp","test","String","includes","isNode","process","browser","exports","module","isBrowser","document","vm","require","unsafeGlobalSrc","runInNewContext","iframe","createElement","style","display","body","appendChild","contentWindow","Set","WeakMap","parentUnsafeRec","self","shims","newShims","shim","currentUnsafeRec"],"mappings":"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"}